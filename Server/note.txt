PROJECT: ft_irc
You have to develop an IRC server in C++ 98.
Your executable will be run as follows:
./ircserv <port> <password>
port: The port number on which your IRC server will be listening to for incoming
IRC connections.
• password: The connection password. It will be needed by any IRC client that tries
to connect to your server.
The server must be capable of handling multiple clients at the same time and never
hang.
• Forking is not allowed. All I/O operations must be non-blocking.
Only 1 poll() (or equivalent) can be used for handling all these operations (read,
write, but also listen, and so forth).
Because you have to use non-blocking file descriptors, it is
possible to use read/recv or write/send functions with no poll()
(or equivalent), and your server wouldn’t be blocking.
But it would consume more system resources.
Thus, if you try to read/recv or write/send in any file descriptor
without using poll() (or equivalent), your grade will be 0.
Communication between client and server has to be done via TCP/IP (v4 or v6).
Since MacOS doesn’t implement write() the same way as other Unix
OSes, you are allowed to use fcntl().
You must use file descriptors in non-blocking mode in order to get a
behavior similar to the one of other Unix OSes.
However, you are allowed to use fcntl() only as follows:
fcntl(fd, F_SETFL, O_NONBLOCK);

Program name: ircserv
Turn in files Makefile, *.{h, hpp}, *.cpp, *.tpp, *.ipp,
Arguments port: The listening port
password: The connection password
External functs. Everything in C++ 98.
socket, close, setsockopt, getsockname,
getprotobyname, gethostbyname, getaddrinfo,
freeaddrinfo, bind, connect, listen, accept,
htons, htonl, ntohs, ntohl, inet_addr, inet_ntoa,
send, recv, signal, lseek, fstat, fcntl, poll (or
equivalent)






Project: ft_irc

Description:
The project involves developing an IRC (Internet Relay Chat) server in C++98. The server should be capable of handling multiple clients simultaneously without hanging. The server will listen for incoming IRC connections on a specified port, and a connection password will be required for clients to connect.

Requirements:

The server must use non-blocking I/O operations. Forking is not allowed.
All I/O operations, including read, write, listen, etc., should be handled using a single poll() or equivalent function.
Communication between the client and server must be done using TCP/IP (v4 or v6).
The server should work on both Unix and macOS systems.
File descriptors must be set to non-blocking mode using fcntl().
Program: ircserv

Executable: ./ircserv
Arguments:
<port>: The port number on which the IRC server will listen for incoming connections.
<password>: The connection password required for clients to connect.
Required Files:

Makefile
Header files (*.h, *.hpp, *.tpp, *.ipp)
Source files (*.cpp)
External Functions:

socket
close
setsockopt
getsockname
getprotobyname
gethostbyname
getaddrinfo
freeaddrinfo
bind
connect
listen
accept
htons
htonl
ntohs
ntohl
inet_addr
inet_ntoa
send
recv
signal
lseek
fstat
fcntl
poll (or equivalent)
Note: The project should be implemented using C++98 and should meet all the specified requirements.


using the below server implementation as a template for the ft_irc project, 
i want to continue from the server.config() and implement the next phase 
which involves handling incoming connections. 
I am not implementing any logs yet. I just want the server up and running.

Requirement.: 
Modify the below code to implement a running server which handles incoming connections
Mandatories: 
1. Remove all log and BOT implementation and any unnecessary details,
2. Use only  c++98 standard functions. 
3. dont use the libft and remove anything concerning BOT for now.


Handle the signals (isOnline)

void Server::run() {
    if (!m_status)
        throw std::runtime_error("Server: Offline, must init first");

    setPFD(m_socket);

    while (isOnline()) {
        if (poll(m_pFD.data(), m_pFD.size(), -1) < 0) {
            int err = errno;
            if (err != EINTR) {
                throw std::runtime_error("Server: poll error");
            }
        }

        for (size_t i = 0; i < m_pFD.size(); i++) {
            // Something in the OUT Queue
            if (m_pFD[i].revents & POLLOUT && m_pFD[i].fd != m_socket) {
                for (std::deque<std::string>::iterator it = m_clients[i - 1]->getMsgQS().begin(); it != m_clients[i - 1]->getMsgQS().end(); ++it) {
                    send(m_pFD[i].fd, it->c_str(), it->size(), 0);

                    if (!m_clients[i - 1]->getMsgQS().empty())
                        m_clients[i - 1]->getMsgQS().pop_front();
                }
            }

            // Clean up clients that are marked for deletion
            if (m_pFD[i].fd != m_socket && m_clients[i - 1]->isMarkedForDeletion()) {
                removeClient(m_pFD[i].fd);
                break;
            }

            // Something is in the IN Queue
            if (m_pFD[i].revents & POLLIN) {
                // We have a new connection, create a new socket for comms
                if (m_pFD[i].fd == m_socket) {
                    int fd = -1;
                    int addressLen = 0;
                    struct sockaddr_in address;
                    std::memset(&address, 0, sizeof(address));

                    if ((fd = accept(m_socket, (struct sockaddr *)&address, (socklen_t *)&addressLen)) < 0) {
                        int err = errno;
                        throw std::runtime_error("Server: client connection error");
                    }

                    m_clients.push_back(new Clients(fd, inet_ntoa(address.sin_addr)));
                    setPFD(fd);
                }

                // We are receiving a raw message on the client socket
                if (m_pFD[i].fd != m_socket) {
                    int bytesRec = m_clients[i - 1]->receive();

                    if (bytesRec <= 0) {
                        m_clients[i - 1]->markForDeletion(m_pFD[i].fd);
                        break;
                    }

                    m_clientCommand->cmdExecute(m_clients[i - 1]);
                }
            }
        }

        // Clean up Channels that are empty
        if (m_channels.size())
            removeChannel();
    }
}


void Server::run() {
    if (!m_status)
        throw std::runtime_error("Server: Offline, must init first");

    setPFD(m_socket);

    while (isOnline()) {
        if (poll(m_pFD.data(), m_pFD.size(), -1) < 0) {
            int err = errno;
            if (err != EINTR) {
                throw std::runtime_error("Server: poll error");
            }
        }

        for (size_t i = 0; i < m_pFD.size(); i++) {
            // Something in the OUT Queue
            if (m_pFD[i].revents & POLLOUT && m_pFD[i].fd != m_socket) {
                for (std::deque<std::string>::iterator it = m_clients[i - 1]->getMsgQS().begin(); it != m_clients[i - 1]->getMsgQS().end(); ++it) {
                    send(m_pFD[i].fd, it->c_str(), it->size(), 0);

                    if (!m_clients[i - 1]->getMsgQS().empty())
                        m_clients[i - 1]->getMsgQS().pop_front();
                }
            }

            // Clean up clients that are marked for deletion
            if (m_pFD[i].fd != m_socket && m_clients[i - 1]->isMarkedForDeletion()) {
                removeClient(m_pFD[i].fd);
                break;
            }

            // Something is in the IN Queue
            if (m_pFD[i].revents & POLLIN) {
                // We have a new connection, create a new socket for comms
                if (m_pFD[i].fd == m_socket) {
                    int fd = -1;
                    int addressLen = 0;
                    struct sockaddr_in address;
                    std::memset(&address, 0, sizeof(address));

                    if ((fd = accept(m_socket, (struct sockaddr *)&address, (socklen_t *)&addressLen)) < 0) {
                        int err = errno;
                        throw std::runtime_error("Server: client connection error");
                    }

                    m_clients.push_back(new Clients(fd, inet_ntoa(address.sin_addr)));
                    setPFD(fd);
                }

                // We are receiving a raw message on the client socket
                if (m_pFD[i].fd != m_socket) {
                    int bytesRec = m_clients[i - 1]->receive();

                    if (bytesRec <= 0) {
                        m_clients[i - 1]->markForDeletion(m_pFD[i].fd);
                        break;
                    }

                    m_clientCommand->cmdExecute(m_clients[i - 1]);
                }
            }
        }
    }
}
